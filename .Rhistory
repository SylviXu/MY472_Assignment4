stats_base_url <- "https://www.googleapis.com/youtube/v3/videos"
stats_params <- list(
part = "statistics",
id = video_id,
key = api_key
)
stats_response <- GET(url = stats_base_url, query = stats_params)
stats_content <- fromJSON(rawToChar(stats_response$content), flatten = TRUE)
if (length(stats_content$items) == 0) {
return(list(
ViewCount = NA,
CommentCount = NA,
LikeCount = NA,
FavoriteCount = NA
))
}
# Ensure that each statistic is available, else NA
view_count <- ifelse(!is.null(stats_content$items$statistics.viewCount), stats_content$items$statistics.viewCount, NA)
comment_count <- ifelse(!is.null(stats_content$items$statistics.commentCount), stats_content$items$statistics.commentCount, NA)
like_count <- ifelse(!is.null(stats_content$items$statistics.likeCount), stats_content$items$statistics.likeCount, NA)
fav_count <- ifelse(!is.null(stats_content$items$statistics.favoriteCount), stats_content$items$statistics.favoriteCount, NA)
video_stats <- data.frame(Like_Count = like_count,
View_Count = view_count,
Comment_Count = comment_count,
Fav_Count = fav_count)
return(video_stats)
}
# Function to get the latest 5 videos and their statistics
get_latest_videos <- function(channel_id, api_key) {
base_url <- "https://www.googleapis.com/youtube/v3/search"
params <- list(
part = "snippet",
channelId = channel_id,
maxResults = 1,
order = "date",
type = "video",
key = api_key
)
response <- GET(url = base_url, query = params)
content <- fromJSON(rawToChar(response$content), flatten = TRUE)
if (!"items" %in% names(content)) {
stop("No items found in API response.")
}
video_details_list <- list()
for (i in 1:1) {
video_id <- content$items$id.videoId
video_title <- content$items$snippet.title
statistics <- get_video_statistics(video_id[i], api_key)
video_details <- data.frame(
Title = video_title,
ViewCount = statistics$View_Count,
CommentCount = statistics$Comment_Count,
LikeCount = statistics$Like_Count,
FavoriteCount = statistics$Fav_Count,
stringsAsFactors = FALSE
)
video_details_list[[i]] <- video_details
}
return(do.call(rbind, video_details))
}
video_data <- data.frame()
# Fetch the latest 5 videos for each artist
for (i in 1:nrow(sampled_channel)) {
channel_id <- sampled_channel$ids[i]
videos <- get_latest_videos(channel_id, youtube_key)
# Process the videos data as needed
video_data <- rbind(video_data, videos)
}
library(gtrendsR)
library(ggplot2)
library(dplyr)
for (i in seq(1, total_keywords, by = batch_size)) {
batch <- data$Name[i:min(i + batch_size - 1, total_keywords)]
repeat {
tryCatch({
trends_data <- gtrends(batch, time = "today 12-m")
break
}, error = function(e) {
if (grepl("429", e)) {
Sys.sleep(30)  # Wait for 30 seconds before retry
} else {
stop(e)  # Handle other errors differently
}
})
}
interest_over_time <- trends_data$interest_over_time
all_trends <- rbind(all_trends, interest_over_time)
Sys.sleep(5)  # Delay between each batch
}
total_keywords <- length(data$Name)
batch_size <- 5
all_trends <- data.frame()
for (i in seq(1, total_keywords, by = batch_size)) {
batch <- data$Name[i:min(i + batch_size - 1, total_keywords)]
repeat {
tryCatch({
trends_data <- gtrends(batch, time = "today 12-m")
break
}, error = function(e) {
if (grepl("429", e)) {
Sys.sleep(30)  # Wait for 30 seconds before retry
} else {
stop(e)  # Handle other errors differently
}
})
}
interest_over_time <- trends_data$interest_over_time
all_trends <- rbind(all_trends, interest_over_time)
Sys.sleep(5)  # Delay between each batch
}
View(data)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(echo = FALSE)
# Load packages
library(rvest)
library(xml2)
library(dplyr)
library(spotifyr)
library(jsonlite)
library(httr)
library(tidyverse)
## Step 1: scrape the 100 greatest artists data from Rolling Stone webpage.======
# Scrape the first page's 50 artists.
# Navigate to the webpage.
website <- "https://www.rollingstone.com/music/music-lists/100-greatest-artists-147446/"
# Read the page's html.
res <- read_html(website)
# Get the 51-100 artists' data.
rank_51_100 <- res %>%
html_nodes("h2") %>%
html_text() %>%
as.data.frame() %>%
head(50)
colnames(rank_51_100) <- "Name" #Rename the column.
rank_51_100$Rank <- 100:51 #Add ranking numbers.
# Navigate to the next page which contains 1-50 artists' data.
website2 <- "https://www.rollingstone.com/music/music-lists/100-greatest-artists-147446/the-band-2-88489/"
res2 <- read_html(website2)
rank_1_50 <- res2 %>%
html_nodes("h2") %>%
html_text() %>%
as.data.frame() %>%
head(50)
colnames(rank_1_50) <- "Name" #Rename the column.
rank_1_50$Rank <- 50:1 #Add ranking numbers.
# Combine two data frames into one single table.
greatest_100_artists <- bind_rows(rank_51_100, rank_1_50) %>%
arrange(Rank)
# Review the first few rows of retrieved data.
head(greatest_100_artists)
# Load packages
library(rvest)
library(xml2)
library(dplyr)
library(spotifyr)
library(jsonlite)
library(httr)
library(tidyverse)
## Step 1: scrape the 100 greatest artists data from Rolling Stone webpage.======
# Scrape the first page's 50 artists.
# Navigate to the webpage.
website <- "https://www.rollingstone.com/music/music-lists/100-greatest-artists-147446/"
# Read the page's html.
res <- read_html(website)
# Get the 51-100 artists' data.
rank_51_100 <- res %>%
html_nodes("h2") %>%
html_text() %>%
as.data.frame() %>%
head(50)
colnames(rank_51_100) <- "Name" #Rename the column.
rank_51_100$Rank <- 100:51 #Add ranking numbers.
# Navigate to the next page which contains 1-50 artists' data.
website2 <- "https://www.rollingstone.com/music/music-lists/100-greatest-artists-147446/the-band-2-88489/"
res2 <- read_html(website2)
rank_1_50 <- res2 %>%
html_nodes("h2") %>%
html_text() %>%
as.data.frame() %>%
head(50)
colnames(rank_1_50) <- "Name" #Rename the column.
rank_1_50$Rank <- 50:1 #Add ranking numbers.
# Combine two data frames into one single table.
greatest_100_artists <- bind_rows(rank_51_100, rank_1_50) %>%
arrange(Rank)
# Review the first few rows of retrieved data.
print(greatest_100_artists[1:10])
print(greatest_100_artists[1:10, ])
# Review the first few rows of the updated dataframe.
data <- read.csv("artists_spotify_data")
head(data)
## Visualisation ==========================================================
# Load "plotly" package for generating interactive plots.
library(plotly)
library(ggplot2)
# Convert the Name column to a factor and keep the original order.
data$Name <- factor(data$Name, levels = unique(data$Name))
# Create a new text column that formats the hover message to be displayed as a string.
data$hover_info <- paste("Name:", data$Name, "<br>Followers:", data$followers, "<br>Rank:", data$Rank)
# Create a column plot to display the Spotify followers of the artists.
follower <- ggplot(data, aes(y = Name, x = followers, text = hover_info)) + # Here set up the text parameter for hover information display.
geom_col() + # Create a column plot.
theme_light() + # Set up the theme.
theme(axis.text.y = element_text(size = 5), # Set up the size of the text.
axis.title.y = element_blank(), # Hide the title of the y axis.
plot.title = element_text(face = "bold"))+ # Set the title font.
labs(title = "P1. The Spotify Followers of the 100 Greatest Artists", x = "Followers") # Add a title.
ggplotly(follower, tooltip = "text") # Display the interactive plot.
# Create some popularity thresholds for analysis.
data_reverse <- data[order(-data$popularity),] # Reorder the artists data.
data_reverse$Name <- factor(data_reverse$Name, levels = data_reverse$Name) # Convert the Name column into a factor.
divider_position <- which(data_reverse$popularity == 50)[1] # Find the first threshold where popularity score equals to 50.
divider_position2 <- which(data_reverse$popularity == 75)[2] # Find another threshold where popularity score equals to 75.
# Create a heat map to show the popularity of all artists.
data$hover_info2 <- paste("Name:", data$Name, "<br>Popularity:", data$popularity, "<br>Rank:", data$Rank) # Set the hover information.
heatmap <- ggplot(data, aes(x = Name, y = 1, fill = popularity, text = hover_info2)) +
geom_tile(color = "white") + # Create a tile plot.
labs(title = "P2. The Spotify Popularity Score of the 100 Greates Artists") +
theme_minimal() + # Set up the theme.
theme(plot.title = element_text(face = "bold"), # Set up the title font.
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 8), # Set the text of the x axis.
axis.text.y = element_blank(), # Hide the text of the y axis.
axis.ticks.y = element_blank(), # Hide the scale on the y axis of the chart.
axis.title.y = element_blank(), # Hide the title of the y axis.
axis.title.x = element_blank(), # Hide the title of the x axis.
panel.grid = element_blank()) + # Hide the grid.
scale_fill_gradientn(colors = c("white", "lightyellow", "red")) # Specify a gradient fill.
ggplotly(heatmap, tooltip = "text") # Display the interactive plot.
# Create another heat map to show the popularity of all artists after sorting in reverse order of the popularity index.
# This is done for comparing the differences between the rankings and popularity of all artists.
heatmap_compare <- ggplot(data, aes(x = reorder(Name, -popularity), y = 1, fill = popularity, text = hover_info2)) +
geom_tile() + # Create a tile plot.
geom_vline(xintercept = divider_position, color = "darkblue", linetype = "dashed", linewidth = 0.3) +
geom_vline(xintercept = divider_position2, color = "darkblue", linetype = "dashed", linewidth = 0.3) +
labs(title = "P2-2. The Spotify Popularity Score of the 100 Greates Artists", x = "Name", y = "", fill = "Popularity") + # Set the labs.
annotate("text", label = "Popularity score: 50", x = divider_position, y = 1, angle = 90, vjust = -0.5, color = "darkblue", size = 3) +
annotate("text", label = "Popularity score: 75", x = divider_position2, y = 1, angle = 90, vjust = -0.5, color = "darkblue", size = 3) +
annotate("text", label = "26%", x = divider_position2/2, y = 1.25, color = "darkgreen") +
annotate("text", label = "64%", x = (divider_position+divider_position2)/2, y = 1.25, color = 'darkgreen') +
annotate("text", label = "10%", x = (divider_position+100)/2, y = 1.25, color = 'darkgreen') +
theme_minimal() + # Set up the theme.
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 8), # Set the text of the x axis.
axis.text.y = element_blank(), # Hide the text of the y axis.
axis.ticks.y = element_blank(), # Hide the scale on the y axis of the chart.
axis.title.y = element_blank(), # Hide the title of the y axis.
axis.title.x = element_blank(), # Hide the title of the x axis.
panel.grid = element_blank(), # Hide the grid.
plot.title = element_text(face  = "bold")) + # Set the title font.
scale_fill_gradientn(colors = c("white", "lightyellow", "red")) # Specify a gradient fill.
ggplotly(heatmap_compare, tooltip = "text") # Display the interactive plot.
## Visualisation ==========================================================
# Load "plotly" package for generating interactive plots.
library(plotly)
library(ggplot2)
# Convert the Name column to a factor and keep the original order.
data$Name <- factor(data$Name, levels = unique(data$Name))
# Create a new text column that formats the hover message to be displayed as a string.
data$hover_info <- paste("Name:", data$Name, "<br>Followers:", data$followers, "<br>Rank:", data$Rank)
# Create a column plot to display the Spotify followers of the artists.
follower <- ggplot(data, aes(y = Name, x = followers, text = hover_info)) + # Here set up the text parameter for hover information display.
geom_col() + # Create a column plot.
theme_light() + # Set up the theme.
theme(axis.text.y = element_text(size = 5), # Set up the size of the text.
axis.title.y = element_blank(), # Hide the title of the y axis.
plot.title = element_text(face = "bold"))+ # Set the title font.
labs(title = "P1. The Spotify Followers of the 100 Greatest Artists", x = "Followers") # Add a title.
ggplotly(follower, tooltip = "text") # Display the interactive plot.
# Create some popularity thresholds for analysis.
data_reverse <- data[order(-data$popularity),] # Reorder the artists data.
data_reverse$Name <- factor(data_reverse$Name, levels = data_reverse$Name) # Convert the Name column into a factor.
divider_position <- which(data_reverse$popularity == 50)[1] # Find the first threshold where popularity score equals to 50.
divider_position2 <- which(data_reverse$popularity == 75)[2] # Find another threshold where popularity score equals to 75.
# Create a heat map to show the popularity of all artists.
data$hover_info2 <- paste("Name:", data$Name, "<br>Popularity:", data$popularity, "<br>Rank:", data$Rank) # Set the hover information.
heatmap <- ggplot(data, aes(x = Name, y = 1, fill = popularity, text = hover_info2)) +
geom_tile(color = "white") + # Create a tile plot.
labs(title = "P2. The Spotify Popularity Score of the 100 Greates Artists") +
theme_minimal() + # Set up the theme.
theme(plot.title = element_text(face = "bold"), # Set up the title font.
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 8), # Set the text of the x axis.
axis.text.y = element_blank(), # Hide the text of the y axis.
axis.ticks.y = element_blank(), # Hide the scale on the y axis of the chart.
axis.title.y = element_blank(), # Hide the title of the y axis.
axis.title.x = element_blank(), # Hide the title of the x axis.
panel.grid = element_blank()) + # Hide the grid.
scale_fill_gradientn(colors = c("white", "lightyellow", "red")) # Specify a gradient fill.
ggplotly(heatmap, tooltip = "text") # Display the interactive plot.
# Create some popularity thresholds for analysis.
data_reverse <- data[order(-data$popularity),] # Reorder the artists data.
data_reverse$Name <- factor(data_reverse$Name, levels = data_reverse$Name) # Convert the Name column into a factor.
divider_position <- which(data_reverse$popularity == 50)[1] # Find the first threshold where popularity score equals to 50.
divider_position2 <- which(data_reverse$popularity == 75)[2] # Find another threshold where popularity score equals to 75.
# Create another heat map to show the popularity of all artists after sorting in reverse order of the popularity index.
# This is done for comparing the differences between the rankings and popularity of all artists.
heatmap_compare <- ggplot(data, aes(x = reorder(Name, -popularity), y = 1, fill = popularity, text = hover_info2)) +
geom_tile() + # Create a tile plot.
geom_vline(xintercept = divider_position, color = "darkblue", linetype = "dashed", linewidth = 0.3) +
geom_vline(xintercept = divider_position2, color = "darkblue", linetype = "dashed", linewidth = 0.3) +
labs(title = "P2-2. The Spotify Popularity Score of the 100 Greates Artists", x = "Name", y = "", fill = "Popularity") + # Set the labs.
annotate("text", label = "Popularity score: 50", x = divider_position, y = 1, angle = 90, vjust = -0.5, color = "darkblue", size = 3) +
annotate("text", label = "Popularity score: 75", x = divider_position2, y = 1, angle = 90, vjust = -0.5, color = "darkblue", size = 3) +
annotate("text", label = "26%", x = divider_position2/2, y = 1.25, color = "darkgreen") +
annotate("text", label = "64%", x = (divider_position+divider_position2)/2, y = 1.25, color = 'darkgreen') +
annotate("text", label = "10%", x = (divider_position+100)/2, y = 1.25, color = 'darkgreen') +
theme_minimal() + # Set up the theme.
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 8), # Set the text of the x axis.
axis.text.y = element_blank(), # Hide the text of the y axis.
axis.ticks.y = element_blank(), # Hide the scale on the y axis of the chart.
axis.title.y = element_blank(), # Hide the title of the y axis.
axis.title.x = element_blank(), # Hide the title of the x axis.
panel.grid = element_blank(), # Hide the grid.
plot.title = element_text(face  = "bold")) + # Set the title font.
scale_fill_gradientn(colors = c("white", "lightyellow", "red")) # Specify a gradient fill.
ggplotly(heatmap_compare, tooltip = "text") # Display the interactive plot.
for (i in seq(1, total_keywords, by = batch_size)) {
batch <- data$Name[i:min(i + batch_size - 1, total_keywords)]
repeat {
tryCatch({
trends_data <- gtrends(batch, time = "today 12-m")
break
}, error = function(e) {
if (grepl("429", e)) {
Sys.sleep(30)  # Wait for 30 seconds before retry
} else {
stop(e)  # Handle other errors differently
}
})
}
interest_over_time <- trends_data$interest_over_time
all_trends <- rbind(all_trends, interest_over_time)
Sys.sleep(5)  # Delay between each batch
}
total_keywords <- length(data$Name)
batch_size <- 5
all_trends <- data.frame()
for (i in seq(1, total_keywords, by = batch_size)) {
batch <- data$Name[i:min(i + batch_size - 1, total_keywords)]
repeat {
tryCatch({
trends_data <- gtrends(batch, time = "today 12-m")
break
}, error = function(e) {
if (grepl("429", e)) {
Sys.sleep(30)  # Wait for 30 seconds before retry
} else {
stop(e)  # Handle other errors differently
}
})
}
interest_over_time <- trends_data$interest_over_time
all_trends <- rbind(all_trends, interest_over_time)
Sys.sleep(5)  # Delay between each batch
}
total_keywords
data1 <- read.csv("artists_spotify_data")
data1
total_keywords <- length(data1$Name)
batch_size <- 5
all_trends <- data.frame()
for (i in seq(1, total_keywords, by = batch_size)) {
batch <- data$Name[i:min(i + batch_size - 1, total_keywords)]
repeat {
tryCatch({
trends_data <- gtrends(batch, time = "today 12-m")
break
}, error = function(e) {
if (grepl("429", e)) {
Sys.sleep(30)  # Wait for 30 seconds before retry
} else {
stop(e)  # Handle other errors differently
}
})
}
interest_over_time <- trends_data$interest_over_time
all_trends <- rbind(all_trends, interest_over_time)
Sys.sleep(5)  # Delay between each batch
}
library(gtrendsR)
library(ggplot2)
library(dplyr)
for (i in seq(1, total_keywords, by = batch_size)) {
batch <- data$Name[i:min(i + batch_size - 1, total_keywords)]
repeat {
tryCatch({
trends_data <- gtrends(batch, time = "today 12-m")
break
}, error = function(e) {
if (grepl("429", e)) {
Sys.sleep(30)  # Wait for 30 seconds before retry
} else {
stop(e)  # Handle other errors differently
}
})
}
interest_over_time <- trends_data$interest_over_time
all_trends <- rbind(all_trends, interest_over_time)
Sys.sleep(5)  # Delay between each batch
}
total_keywords
data1$Name
total_keywords <- length(data1$Name)
batch_size <- 5
all_trends <- data.frame()
for (i in seq(1, total_keywords, by = batch_size)) {
batch <- data$Name[i:min(i + batch_size - 1, total_keywords)]
repeat {
tryCatch({
trends_data <- gtrends(batch, time = "today 12-m")
break
}, error = function(e) {
if (grepl("429", e)) {
Sys.sleep(30)  # Wait for 30 seconds before retry
} else {
stop(e)  # Handle other errors differently
}
})
}
interest_over_time <- trends_data$interest_over_time
all_trends <- rbind(all_trends, interest_over_time)
Sys.sleep(5)  # Delay between each batch
}
for (i in seq(1, total_keywords, by = batch_size)) {
# 确保 batch 是一个向量，即使它只有一个元素
batch <- as.vector(data1$Name[i:min(i + batch_size - 1, total_keywords)])
repeat {
tryCatch({
trends_data <- gtrends(batch, time = "today 12-m")
break
}, error = function(e) {
if (grepl("429", e$message)) {
Sys.sleep(30)  # Wait for 30 seconds before retry
} else {
stop(e)  # Handle other errors differently
}
})
}
interest_over_time <- trends_data$interest_over_time
all_trends <- rbind(all_trends, interest_over_time)
Sys.sleep(5)  # Delay between each batch
}
## Visualisation ==========================================================
# Load "plotly" package for generating interactive plots.
library(plotly)
library(ggplot2)
# Convert the Name column to a factor and keep the original order.
data$Name <- factor(data$Name, levels = unique(data$Name))
# Create a new text column that formats the hover message to be displayed as a string.
data$hover_info <- paste("Name:", data$Name, "<br>Followers:", data$followers, "<br>Rank:", data$Rank)
# Create a column plot to display the Spotify followers of the artists.
follower <- ggplot(data, aes(y = Name, x = followers, text = hover_info)) + # Here set up the text parameter for hover information display.
geom_col() + # Create a column plot.
theme_light() + # Set up the theme.
theme(axis.text.y = element_text(size = 5), # Set up the size of the text.
axis.title.y = element_blank(), # Hide the title of the y axis.
plot.title = element_text(face = "bold"))+ # Set the title font.
labs(title = "P1. The Spotify Followers of the 100 Greatest Artists", x = "Followers") # Add a title.
ggplotly(follower, tooltip = "text") # Display the interactive plot.
all_trends$hits <- as.numeric(all_trends$hits)
all_trends[is.na(all_trends)] <- 0
all_trends
all_trends %>%
ggplot()+
geom_line(aes(x = date, y = hits, group = keyword, color = keyword))+
scale_y_continuous(
breaks = seq(0, 200, by = 25),
)+
labs(title = "Google Trends Interest Over Time", x = "Date", y = "Search hits") +
theme_light()
search_trends <- all_trends %>%
ggplot()+
geom_line(aes(x = date, y = hits, group = keyword, color = keyword))+
scale_y_continuous(
breaks = seq(0, 200, by = 25),
)+
labs(title = "Google Trends Interest Over Time", x = "Date", y = "Search hits") +
theme_light()
# Load packages
library(rvest)
library(xml2)
library(dplyr)
library(spotifyr)
library(jsonlite)
library(httr)
library(tidyverse)
## Step 1: scrape the 100 greatest artists data from Rolling Stone webpage.======
# Scrape the first page's 50 artists.
# Navigate to the webpage.
website <- "https://www.rollingstone.com/music/music-lists/100-greatest-artists-147446/"
# Read the page's html.
res <- read_html(website)
# Get the 51-100 artists' data.
rank_51_100 <- res %>%
html_nodes("h2") %>%
html_text() %>%
as.data.frame() %>%
head(50)
colnames(rank_51_100) <- "Name" #Rename the column.
rank_51_100$Rank <- 100:51 #Add ranking numbers.
# Navigate to the next page which contains 1-50 artists' data.
website2 <- "https://www.rollingstone.com/music/music-lists/100-greatest-artists-147446/the-band-2-88489/"
res2 <- read_html(website2)
rank_1_50 <- res2 %>%
html_nodes("h2") %>%
html_text() %>%
as.data.frame() %>%
head(50)
colnames(rank_1_50) <- "Name" #Rename the column.
rank_1_50$Rank <- 50:1 #Add ranking numbers.
# Combine two data frames into one single table.
greatest_100_artists <- bind_rows(rank_51_100, rank_1_50) %>%
arrange(Rank)
